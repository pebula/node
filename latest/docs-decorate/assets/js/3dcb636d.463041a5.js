"use strict";(self.webpackChunkdocs_decorate=self.webpackChunkdocs_decorate||[]).push([[626],{2526:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var a=t(6870),n=t(5569);const o={id:"introduction",title:"Introduction",sidebar_label:"1. Introduction"},i=void 0,s={id:"decorate/introduction",title:"Introduction",description:"Decorate (core library) provides a unified framework for decorator management, life-cycle flow and storage.",source:"@site/docs/decorate/introduction.md",sourceDirName:"decorate",slug:"/decorate/introduction",permalink:"/node/decorate/docs/decorate/introduction",draft:!1,unlisted:!1,editUrl:"https://github.com/pebula/node/tree/main/apps/docs/decorate/docs/docs/decorate/introduction.md",tags:[],version:"current",frontMatter:{id:"introduction",title:"Introduction",sidebar_label:"1. Introduction"},sidebar:"sidebar",previous:{title:"2. Installation",permalink:"/node/decorate/docs/getting-started/installation"},next:{title:"1. Introduction",permalink:"/node/decorate/docs/decorate-fluent/introduction"}},c={},d=[{value:"Structure",id:"structure",level:2},{value:"Mixins",id:"mixins",level:2},{value:"Decorator Domain",id:"decorator-domain",level:2},{value:"Target Classifier",id:"target-classifier",level:2}];function l(e){const r={admonition:"admonition",br:"br",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,n.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(r.p,{children:[(0,a.jsx)(r.strong,{children:"Decorate"})," (core library) provides a unified framework for decorator management, life-cycle flow and storage."]}),"\n",(0,a.jsx)(r.h2,{id:"structure",children:"Structure"}),"\n",(0,a.jsx)(r.p,{children:"There are 2 key components:"}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:"Decorator domain"}),"\n",(0,a.jsx)(r.li,{children:"Target Classifier"}),"\n"]}),"\n",(0,a.jsxs)(r.p,{children:["In ",(0,a.jsx)(r.strong,{children:"Decorate"})," we use ",(0,a.jsx)(r.strong,{children:"decorator domains"})," to create strictly typed decorator functions.",(0,a.jsx)(r.br,{}),"\n","All decorators created by the domain are bound to it, grouped together storing the metadata for their decorated targets in the same place, the domain."]}),"\n",(0,a.jsxs)(r.p,{children:["A domain uses a target classifier class to manage metadata related operation for each decorated target.",(0,a.jsx)(r.br,{}),"\n","When creating a new domain you can provide your own target classifier class which extends the core classifier, override some of it's behavior and make work for your requirements."]}),"\n",(0,a.jsx)(r.p,{children:"When a new decorated target is introduces, a new target classifier instance is created, which will store all metadata created by decorators of the domain for that target."}),"\n",(0,a.jsxs)(r.admonition,{type:"info",children:[(0,a.jsxs)(r.p,{children:["A ",(0,a.jsx)(r.strong,{children:"decorated target"})," is the class a decorator decorates (including member decoration)."]}),(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-typescript",children:"class MyDecoratedTarget {\n  @MyDecorator value: number\n}\n"})}),(0,a.jsxs)(r.p,{children:["In the example above, ",(0,a.jsx)(r.code,{children:"MyDecoratedTarget"})," is a decorated target."]})]}),"\n",(0,a.jsx)(r.h2,{id:"mixins",children:"Mixins"}),"\n",(0,a.jsxs)(r.p,{children:["MixinFW + Mixin in decorate",(0,a.jsx)(r.br,{}),"\n","Maybe in chapter on TargetClassifier and how it extends metadata"]}),"\n",(0,a.jsx)(r.h2,{id:"decorator-domain",children:"Decorator Domain"}),"\n",(0,a.jsxs)(r.p,{children:["A ",(0,a.jsx)(r.strong,{children:"decorator domains"})," is like a store which is able to generate decorators and store all the metadata created when they get invoked."]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-typescript",children:"import { DecoratedDomain } from '@pebula/decorate';\n\nexport const domain = new DecoratedDomain();\n"})}),"\n",(0,a.jsx)(r.p,{children:"Now we have a new domain which we can use to create decorators from."}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-typescript",children:"const MyDecor = domain.createDecorator({\n  name: 'MyDecor',\n  allowedScopes: ['property'],\n  classifierData: { } // any data you want to pass forward\n});\n\nconst MyDecorFlat = domain.createImmediateDecorator({\n  name: 'MyDecorFlat',\n  allowedScopes: ['property'],\n  classifierData: { } // any data you want to pass forward\n});\n"})}),"\n",(0,a.jsx)(r.p,{children:"Targets decorated by decorators created in our new domain will be stored in the domain."}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-typescript",children:"class MyApplicationClass {\n  @MyDecor() value: number;\n  @MyDecorFlat value2: number;\n}\n"})}),"\n",(0,a.jsxs)(r.p,{children:["When a decorator is activated, the domain is notified and it will start generating a metadata record.",(0,a.jsx)(r.br,{}),"\n",'The domain has no logic, so we add logic that "tells" the domain what to do when a decorated is invoked.']}),"\n",(0,a.jsxs)(r.p,{children:["The logic is places inside the ",(0,a.jsx)(r.code,{children:"TargetClassifier"})," class.",(0,a.jsx)(r.br,{}),"\n","When a target class is first decorated the domain assign's a classifier to it (",(0,a.jsx)(r.code,{children:"TargetClassifier"}),") which will\nstore all metadata from all decorators on the domain which are invoked on this target."]}),"\n",(0,a.jsxs)(r.p,{children:["The domain will operate using methods on the classifier.",(0,a.jsx)(r.br,{}),"\n","It will use the classifier to:"]}),"\n",(0,a.jsxs)(r.ul,{children:["\n",(0,a.jsx)(r.li,{children:"Create a new metadata records"}),"\n",(0,a.jsx)(r.li,{children:"Extend the metadata from existing metadata on an already decorated base class"}),"\n",(0,a.jsx)(r.li,{children:"Query if the target has metadata for a given decorator"}),"\n"]}),"\n",(0,a.jsxs)(r.p,{children:["The ",(0,a.jsx)(r.code,{children:"TargetClassifier"})," class contains all of the functionality above but it can be replaced by a custom class, which extends ",(0,a.jsx)(r.code,{children:"TargetClassifier"}),"."]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-typescript",children:"export const domain = new DecoratedDomain(MyCustomTargetClassifier);\n"})}),"\n",(0,a.jsx)(r.h2,{id:"target-classifier",children:"Target Classifier"}),"\n",(0,a.jsx)(r.p,{children:"By default when we create a new domain:"}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-typescript",children:"import { DecoratedDomain } from '@pebula/decorate';\n\nexport const domain = new DecoratedDomain();\n"})}),"\n",(0,a.jsxs)(r.p,{children:["The domain is created with the ",(0,a.jsx)(r.code,{children:"TargetClassifier"})," class as the class to manage targets.",(0,a.jsx)(r.br,{}),"\n","We can modify this behavior:"]}),"\n",(0,a.jsx)(r.pre,{children:(0,a.jsx)(r.code,{className:"language-typescript",children:"class MyTargetClassifier extends TargetClassifier {\n  protected createRecord(decor: Decorator | DecoratorInitializer<TRecordMeta>,\n                         record: ClassifierRecord<TRecordMeta>,\n                         options: DecoratorOptions): TRecord {\n    // override behavior\n  }\n\n  protected extendDecoratorMetadata(targetClassifier: TargetClassifier) {\n    // override behavior\n  }\n}\n\nexport const domain = new DecoratedDomain(MyTargetClassifier);\n\n"})})]})}function h(e={}){const{wrapper:r}={...(0,n.R)(),...e.components};return r?(0,a.jsx)(r,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},5569:(e,r,t)=>{t.d(r,{R:()=>i,x:()=>s});var a=t(6326);const n={},o=a.createContext(n);function i(e){const r=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function s(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),a.createElement(o.Provider,{value:r},e.children)}}}]);