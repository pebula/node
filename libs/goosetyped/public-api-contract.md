## API Report File for "@pebula/goosetyped"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="mongoose/types/aggregate" />
/// <reference types="mongoose/types/callback" />
/// <reference types="mongoose/types/collection" />
/// <reference types="mongoose/types/connection" />
/// <reference types="mongoose/types/cursor" />
/// <reference types="mongoose/types/document" />
/// <reference types="mongoose/types/error" />
/// <reference types="mongoose/types/expressions" />
/// <reference types="mongoose/types/helpers" />
/// <reference types="mongoose/types/indexes" />
/// <reference types="mongoose/types/inferschematype" />
/// <reference types="mongoose/types/middlewares" />
/// <reference types="mongoose/types/models" />
/// <reference types="mongoose/types/mongooseoptions" />
/// <reference types="mongoose/types/pipelinestage" />
/// <reference types="mongoose/types/populate" />
/// <reference types="mongoose/types/query" />
/// <reference types="mongoose/types/schemaoptions" />
/// <reference types="mongoose/types/schematypes" />
/// <reference types="mongoose/types/session" />
/// <reference types="mongoose/types/types" />
/// <reference types="mongoose/types/utility" />
/// <reference types="mongoose/types/validation" />
/// <reference types="mongoose/types/virtuals" />

import { Document as Document_2 } from 'mongoose';
import { HydratedDocument } from 'mongoose';
import M from 'mongoose';
import { Model } from 'mongoose';
import * as mongodb from 'mongodb';
import * as mongoose from 'mongoose';
import { default as mongoose_2 } from 'mongoose';
import { NonFunctionKeys } from 'utility-types';
import { Schema } from 'mongoose';
import { SchemaType } from 'mongoose';
import { SchemaTypeOptions } from 'mongoose';
import { SetDifference } from 'utility-types';
import { Subtract } from 'utility-types';
import { Types } from 'mongoose';

// @public
export function addConnection(connectionId: string, connectionFactory: () => (mongoose_2.Connection | Promise<mongoose_2.Connection>), connectOptions?: GtConnectOptions): Promise<unknown>;

// @public (undocumented)
export type ClassDecoratorOf<TInstance, TStatic = any> = (target: Type<TInstance, TStatic>) => any;

// @public (undocumented)
export type ColumnRequired = boolean | string | (() => boolean) | [() => boolean, string];

// @public (undocumented)
export interface Ctor<T> extends Function {
    // (undocumented)
    new (...args: any[]): T;
}

// @public (undocumented)
export class DocumentArray<T extends Document_2> extends Types.DocumentArray<T> {
}

// @public (undocumented)
export interface DocumentQuery<ResultType, DocType, THelpers = {}, RawDocType = DocType, QueryOp = 'find'> {
    // (undocumented)
    $where(argument: string | Function): DocumentQuery<Array<DocType>, DocType, THelpers, RawDocType, QueryOp> & THelpers;
    [Symbol.asyncIterator](): AsyncIterableIterator<mongoose.Unpacked<ResultType>>;
    // (undocumented)
    [Symbol.toStringTag]: string;
    all(path: string, val: Array<any>): this;
    // (undocumented)
    all(val: Array<any>): this;
    allowDiskUse(value: boolean): this;
    and(array: Array<mongoose.FilterQuery<RawDocType>>): this;
    batchSize(val: number): this;
    box(val: any): this;
    // (undocumented)
    box(lower: number[], upper: number[]): this;
    // (undocumented)
    cast(model: mongoose.Model<any, THelpers> | null, obj: any): mongoose.UpdateQuery<DocType>;
    catch: Promise<ResultType>['catch'];
    circle(path: string, area: any): this;
    // (undocumented)
    circle(area: any): this;
    clone(): this;
    collation(value: mongodb.CollationOptions): this;
    comment(val: string): this;
    countDocuments(criteria?: mongoose.FilterQuery<RawDocType>, options?: mongoose.QueryOptions<DocType>): DocumentQuery<number, DocType, THelpers, RawDocType, 'countDocuments'> & THelpers;
    cursor(options?: mongoose.QueryOptions<DocType>): mongoose.Cursor<mongoose.Unpacked<ResultType>, mongoose.QueryOptions<DocType>>;
    deleteMany(filter?: mongoose.FilterQuery<RawDocType>, options?: mongoose.QueryOptions<DocType>): DocumentQuery<any, DocType, THelpers, RawDocType, 'deleteMany'> & THelpers;
    // (undocumented)
    deleteMany(filter: mongoose.FilterQuery<RawDocType>): DocumentQuery<any, DocType, THelpers, RawDocType, 'deleteMany'> & THelpers;
    // (undocumented)
    deleteMany(): DocumentQuery<any, DocType, THelpers, RawDocType, 'deleteMany'> & THelpers;
    deleteOne(filter?: mongoose.FilterQuery<RawDocType>, options?: mongoose.QueryOptions<DocType>): DocumentQuery<any, DocType, THelpers, RawDocType, 'deleteOne'> & THelpers;
    // (undocumented)
    deleteOne(filter: mongoose.FilterQuery<RawDocType>): DocumentQuery<any, DocType, THelpers, RawDocType, 'deleteOne'> & THelpers;
    // (undocumented)
    deleteOne(): DocumentQuery<any, DocType, THelpers, RawDocType, 'deleteOne'> & THelpers;
    distinct<DocKey extends string, ResultType = unknown>(field: DocKey, filter?: mongoose.FilterQuery<RawDocType>): DocumentQuery<Array<DocKey extends keyof DocType ? mongoose.Unpacked<DocType[DocKey]> : ResultType>, DocType, THelpers, RawDocType, 'distinct'> & THelpers;
    elemMatch<K = string>(path: K, val: any): this;
    // (undocumented)
    elemMatch(val: Function | any): this;
    equals(val: any): this;
    error(): NativeError | null;
    // (undocumented)
    error(val: NativeError | null): this;
    estimatedDocumentCount(options?: mongoose.QueryOptions<DocType>): DocumentQuery<number, DocType, THelpers, RawDocType, 'estimatedDocumentCount'> & THelpers;
    exec(): Promise<ResultType>;
    exists<K = string>(path: K, val: boolean): this;
    // (undocumented)
    exists(val: boolean): this;
    explain(verbose?: mongodb.ExplainVerbosityLike): this;
    finally: Promise<ResultType>['finally'];
    find(filter: mongoose.FilterQuery<RawDocType>, projection?: mongoose.ProjectionType<RawDocType> | null, options?: mongoose.QueryOptions<DocType> | null): DocumentQuery<Array<DocType>, DocType, THelpers, RawDocType, 'find'> & THelpers;
    // (undocumented)
    find(filter: mongoose.FilterQuery<RawDocType>, projection?: mongoose.ProjectionType<RawDocType> | null): DocumentQuery<Array<DocType>, DocType, THelpers, RawDocType, 'find'> & THelpers;
    // (undocumented)
    find(filter: mongoose.FilterQuery<RawDocType>): DocumentQuery<Array<DocType>, DocType, THelpers, RawDocType, 'find'> & THelpers;
    // (undocumented)
    find(): DocumentQuery<Array<DocType>, DocType, THelpers, RawDocType, 'find'> & THelpers;
    findById(id: mongodb.ObjectId | any, projection?: mongoose.ProjectionType<RawDocType> | null, options?: mongoose.QueryOptions<DocType> | null): DocumentQuery<DocType | null, DocType, THelpers, RawDocType, 'findOne'> & THelpers;
    // (undocumented)
    findById(id: mongodb.ObjectId | any, projection?: mongoose.ProjectionType<RawDocType> | null): DocumentQuery<DocType | null, DocType, THelpers, RawDocType, 'findOne'> & THelpers;
    // (undocumented)
    findById(id: mongodb.ObjectId | any): DocumentQuery<DocType | null, DocType, THelpers, RawDocType, 'findOne'> & THelpers;
    findByIdAndDelete(id: mongodb.ObjectId | any, options: mongoose.QueryOptions<DocType> & {
        includeResultMetadata: true;
    }): DocumentQuery<mongoose.ModifyResult<DocType>, DocType, THelpers, RawDocType, 'findOneAndDelete'> & THelpers;
    // (undocumented)
    findByIdAndDelete(id?: mongodb.ObjectId | any, options?: mongoose.QueryOptions<DocType> | null): DocumentQuery<DocType | null, DocType, THelpers, RawDocType, 'findOneAndDelete'> & THelpers;
    findByIdAndUpdate(id: mongodb.ObjectId | any, update: mongoose.UpdateQuery<RawDocType>, options: mongoose.QueryOptions<DocType> & {
        includeResultMetadata: true;
    }): DocumentQuery<mongoose.ModifyResult<DocType>, DocType, THelpers, RawDocType, 'findOneAndUpdate'> & THelpers;
    // (undocumented)
    findByIdAndUpdate(id: mongodb.ObjectId | any, update: mongoose.UpdateQuery<RawDocType>, options: mongoose.QueryOptions<DocType> & {
        upsert: true;
    } & mongoose.ReturnsNewDoc): DocumentQuery<DocType, DocType, THelpers, RawDocType, 'findOneAndUpdate'> & THelpers;
    // (undocumented)
    findByIdAndUpdate(id?: mongodb.ObjectId | any, update?: mongoose.UpdateQuery<RawDocType>, options?: mongoose.QueryOptions<DocType> | null): DocumentQuery<DocType | null, DocType, THelpers, RawDocType, 'findOneAndUpdate'> & THelpers;
    // (undocumented)
    findByIdAndUpdate(id: mongodb.ObjectId | any, update: mongoose.UpdateQuery<RawDocType>): DocumentQuery<DocType | null, DocType, THelpers, RawDocType, 'findOneAndUpdate'> & THelpers;
    findOne(filter?: mongoose.FilterQuery<RawDocType>, projection?: mongoose.ProjectionType<RawDocType> | null, options?: mongoose.QueryOptions<DocType> | null): DocumentQuery<DocType | null, DocType, THelpers, RawDocType, 'findOne'> & THelpers;
    // (undocumented)
    findOne(filter?: mongoose.FilterQuery<RawDocType>, projection?: mongoose.ProjectionType<RawDocType> | null): DocumentQuery<DocType | null, DocType, THelpers, RawDocType, 'findOne'> & THelpers;
    // (undocumented)
    findOne(filter?: mongoose.FilterQuery<RawDocType>): DocumentQuery<DocType | null, DocType, THelpers, RawDocType, 'findOne'> & THelpers;
    findOneAndDelete(filter?: mongoose.FilterQuery<RawDocType>, options?: mongoose.QueryOptions | null): DocumentQuery<DocType | null, DocType, THelpers, RawDocType, 'findOneAndDelete'> & THelpers;
    findOneAndUpdate(filter: mongoose.FilterQuery<RawDocType>, update: mongoose.UpdateQuery<RawDocType>, options: mongoose.QueryOptions & {
        includeResultMetadata: true;
    }): DocumentQuery<mongoose.ModifyResult<DocType>, DocType, THelpers, RawDocType, 'findOneAndUpdate'> & THelpers;
    // (undocumented)
    findOneAndUpdate(filter: mongoose.FilterQuery<RawDocType>, update: mongoose.UpdateQuery<RawDocType>, options: mongoose.QueryOptions & {
        upsert: true;
    } & mongoose.ReturnsNewDoc): DocumentQuery<DocType, DocType, THelpers, RawDocType, 'findOneAndUpdate'> & THelpers;
    // (undocumented)
    findOneAndUpdate(filter?: mongoose.FilterQuery<RawDocType>, update?: mongoose.UpdateQuery<RawDocType>, options?: mongoose.QueryOptions<DocType> | null): DocumentQuery<DocType | null, DocType, THelpers, RawDocType, 'findOneAndUpdate'> & THelpers;
    geometry(object: {
        type: string;
        coordinates: any[];
    }): this;
    get(path: string): any;
    getFilter(): mongoose.FilterQuery<DocType>;
    getOptions(): mongoose.QueryOptions;
    getPopulatedPaths(): Array<string>;
    getQuery(): mongoose.FilterQuery<DocType>;
    getUpdate(): mongoose.UpdateQuery<DocType> | null;
    gt<K = string>(path: K, val: any): this;
    // (undocumented)
    gt(val: number): this;
    gte<K = string>(path: K, val: any): this;
    // (undocumented)
    gte(val: number): this;
    hint(val: any): this;
    in<K = string>(path: K, val: any[]): this;
    // (undocumented)
    in(val: Array<any>): this;
    intersects(arg?: any): this;
    j(val: boolean | null): this;
    // (undocumented)
    lean<LeanResultType = mongoose.GetLeanResultType<RawDocType, ResultType, QueryOp>>(val?: boolean | any): DocumentQuery<ResultType extends null ? LeanResultType | null : LeanResultType, DocType, THelpers, RawDocType, QueryOp> & THelpers;
    limit(val: number): this;
    lt<K = string>(path: K, val: any): this;
    // (undocumented)
    lt(val: number): this;
    lte<K = string>(path: K, val: any): this;
    // (undocumented)
    lte(val: number): this;
    maxDistance(path: string, val: number): this;
    // (undocumented)
    maxDistance(val: number): this;
    maxTimeMS(ms: number): this;
    merge(source: mongoose.Query<any, any> | mongoose.FilterQuery<RawDocType> | DocumentQuery<any, any>): this;
    mod<K = string>(path: K, val: number): this;
    // (undocumented)
    mod(val: Array<number>): this;
    model: ExtModel<DocType, unknown>;
    mongooseOptions(val?: mongoose.MongooseQueryOptions): mongoose.MongooseQueryOptions;
    // (undocumented)
    _mongooseOptions: mongoose.MongooseQueryOptions;
    ne<K = string>(path: K, val: any): this;
    // (undocumented)
    ne(val: any): this;
    near<K = string>(path: K, val: any): this;
    // (undocumented)
    near(val: any): this;
    nin<K = string>(path: K, val: any[]): this;
    // (undocumented)
    nin(val: Array<any>): this;
    nor(array: Array<mongoose.FilterQuery<RawDocType>>): this;
    or(array: Array<mongoose.FilterQuery<RawDocType>>): this;
    orFail(err?: NativeError | (() => NativeError)): DocumentQuery<NonNullable<ResultType>, DocType, THelpers, RawDocType, QueryOp> & THelpers;
    polygon(path: string, ...coordinatePairs: number[][]): this;
    // (undocumented)
    polygon(...coordinatePairs: number[][]): this;
    populate(path: string | string[], select?: string | any, model?: string | mongoose.Model<any, THelpers>, match?: any): DocumentQuery<ResultType, DocType, THelpers, RawDocType, QueryOp> & THelpers;
    // (undocumented)
    populate(options: mongoose.PopulateOptions | (mongoose.PopulateOptions | string)[]): DocumentQuery<ResultType, DocType, THelpers, RawDocType, QueryOp> & THelpers;
    // (undocumented)
    populate<Paths>(path: string | string[], select?: string | any, model?: string | mongoose.Model<any, THelpers>, match?: any): DocumentQuery<mongoose.MergePopulatePaths<RawDocType, ResultType, QueryOp, Paths, THelpers>, DocType, THelpers, mongoose.UnpackedIntersection<RawDocType, Paths>, QueryOp> & THelpers;
    // (undocumented)
    populate<Paths>(options: mongoose.PopulateOptions | (mongoose.PopulateOptions | string)[]): DocumentQuery<mongoose.MergePopulatePaths<RawDocType, ResultType, QueryOp, Paths, THelpers>, DocType, THelpers, mongoose.UnpackedIntersection<RawDocType, Paths>, QueryOp> & THelpers;
    post(fn: Function): this;
    pre(fn: Function): this;
    projection(fields?: mongoose.ProjectionFields<DocType> | string): mongoose.ProjectionFields<DocType>;
    // (undocumented)
    projection(fields: null): null;
    // (undocumented)
    projection(): mongoose.ProjectionFields<DocType> | null;
    read(pref: string | mongodb.ReadPreferenceMode, tags?: any[]): this;
    readConcern(level: string): this;
    regex<K = string>(path: K, val: RegExp): this;
    // (undocumented)
    regex(val: string | RegExp): this;
    replaceOne(filter?: mongoose.FilterQuery<RawDocType>, replacement?: DocType | mongoose.AnyObject, options?: mongoose.QueryOptions<DocType> | null): DocumentQuery<any, DocType, THelpers, RawDocType, 'replaceOne'> & THelpers;
    select<RawDocTypeOverride extends {
        [P in keyof RawDocType]?: any;
    } = {}>(arg: string | string[] | Record<string, number | boolean | string | object>): DocumentQuery<mongoose.IfEquals<RawDocTypeOverride, {}, ResultType, ResultType extends any[] ? ResultType extends mongoose.HydratedDocument<any>[] ? mongoose.HydratedDocument<RawDocTypeOverride>[] : RawDocTypeOverride[] : (ResultType extends mongoose.HydratedDocument<any> ? mongoose.HydratedDocument<RawDocTypeOverride> : RawDocTypeOverride) | (null extends ResultType ? null : never)>, DocType, THelpers, mongoose.IfEquals<RawDocTypeOverride, {}, RawDocType, RawDocTypeOverride>, QueryOp> & THelpers;
    selected(): boolean;
    selectedExclusively(): boolean;
    selectedInclusively(): boolean;
    session(session: mongodb.ClientSession | null): this;
    set(path: string | Record<string, unknown>, value?: any): this;
    setOptions(options: mongoose.QueryOptions<DocType>, overwrite?: boolean): this;
    setQuery(val: mongoose.FilterQuery<RawDocType> | null): void;
    // (undocumented)
    setUpdate(update: mongoose.UpdateQuery<RawDocType> | mongoose.UpdateWithAggregationPipeline): void;
    size<K = string>(path: K, val: number): this;
    // (undocumented)
    size(val: number): this;
    skip(val: number): this;
    slice(path: string, val: number | Array<number>): this;
    // (undocumented)
    slice(val: number | Array<number>): this;
    sort(arg?: string | {
        [key: string]: mongoose.SortOrder | {
            $meta: any;
        };
    } | [string, mongoose.SortOrder][] | undefined | null, options?: {
        override?: boolean;
    }): this;
    tailable(bool?: boolean, opts?: {
        numberOfRetries?: number;
        tailableRetryInterval?: number;
    }): this;
    then: Promise<ResultType>['then'];
    toConstructor<RetType = typeof mongoose.Query>(): RetType;
    transform<MappedType>(fn: (doc: ResultType) => MappedType): DocumentQuery<MappedType, DocType, THelpers, RawDocType, QueryOp> & THelpers;
    updateMany(filter?: mongoose.FilterQuery<RawDocType>, update?: mongoose.UpdateQuery<RawDocType> | mongoose.UpdateWithAggregationPipeline, options?: mongoose.QueryOptions<DocType> | null): DocumentQuery<mongoose.UpdateWriteOpResult, DocType, THelpers, RawDocType, 'updateMany'> & THelpers;
    updateOne(filter?: mongoose.FilterQuery<RawDocType>, update?: mongoose.UpdateQuery<RawDocType> | mongoose.UpdateWithAggregationPipeline, options?: mongoose.QueryOptions<DocType> | null): DocumentQuery<mongoose.UpdateWriteOpResult, DocType, THelpers, RawDocType, 'updateOne'> & THelpers;
    w(val: string | number | null): this;
    where(path: string, val?: any): this;
    // (undocumented)
    where(obj: object): this;
    // (undocumented)
    where(): this;
    within(val?: any): this;
    wtimeout(ms: number): this;
}

// @public
export function findModels(): Array<Model<any> | Resource>;

// @public
export function getDiscriminatorKeyFor(modelClass: Ctor<any>): string | undefined;

// @public
export function getDiscriminatorKeysOf(modelClass: Ctor<any>): string[];

// @public
export function getEnum<T>(cls: Ctor<T>, path: keyof T): string[];

// @public
export function getSchemaOf<T>(modelClass: Ctor<T>): Schema | undefined;

// @public (undocumented)
export interface GtBeforeCompileModelHandler {
    // (undocumented)
    schema: mongoose_2.Schema;
    // (undocumented)
    target: Ctor<any>;
}

// @public (undocumented)
export function GtColumn<T = any>(metadata?: GtColumnMetadataArgs<T>): PropertyDecoratorOf<any>;

// @public (undocumented)
export interface GtColumnMetadataArgs<T> {
    default?: T | ((...args: any[]) => T);
    // (undocumented)
    enum?: string[] | number[] | object;
    immutable?: boolean;
    required?: ColumnRequired;
    select?: boolean;
    skipVersioning?: boolean;
    type?: Schema | typeof SchemaType | (() => Type<any, any>);
    validate?: Validator;
}

// @public (undocumented)
export interface GtCompoundIndexMetadataArgs {
    // (undocumented)
    indices: {
        [indexName: string]: GtIndexSortOrder;
    };
    // (undocumented)
    options?: GtIndexOptions;
}

// @public (undocumented)
export interface GtConnectOptions {
    beforeCompile?: (handler: GtBeforeCompileModelHandler) => void;
    compileAt?: 'immediate' | 'connected';
}

// @public (undocumented)
export function GtDeleteOneHook(stage: 'pre' | 'post'): MethodDecoratorOf<never, any>;

// @public (undocumented)
export function GtDiscriminator(): PropertyDecoratorOf<string>;

// @public (undocumented)
export function GtDocument(metadata?: GtDocumentMetadataArgs): ClassDecoratorOf<ExtModel<any, any>>;

// @public (undocumented)
export interface GtDocumentMetadataArgs extends GtSchemaMetadataArgs {
    autoCreate?: boolean;
    autoIndex?: boolean;
    bufferCommands?: boolean;
    capped?: boolean | number | {
        size?: number;
        max?: number;
        autoIndexId?: boolean;
    };
    collation?: mongodb.CollationOptions;
    collection?: string;
    connectionId?: string;
    minimize?: boolean;
}

// @public (undocumented)
export function GtIndex(metadata?: GtSingleIndexMetadataArgs): PropertyDecorator;

// @public (undocumented)
export function GtIndex(metadata: GtCompoundIndexMetadataArgs): ClassDecorator;

// @public (undocumented)
export interface GtIndexOptions {
    background?: boolean;
    sparse?: boolean | any;
    text?: boolean | any;
    unique?: boolean | any;
}

// @public (undocumented)
export type GtIndexSortOrder = 'asc' | 'desc';

// @public (undocumented)
export function GtInitHook(stage: 'pre' | 'post'): MethodDecoratorOf<never, void>;

// @public (undocumented)
export function GtInsertManyHook(stage: 'post'): StaticMethodDecoratorOf<[any[]], any>;

// @public (undocumented)
export function GtInsertManyHook(stage: 'pre'): StaticMethodDecoratorOf<never, any>;

// @public (undocumented)
export function GtLocalProp(): PropertyDecorator;

// @public (undocumented)
export function GtMethod(): MethodDecorator;

// @public (undocumented)
export function GtModel<T1, C1, T2, C2, T3, C3, T4, C4, T5, C5>(m1?: C1 & Ctor<T1>, m2?: C2 & Ctor<T2>, m3?: C3 & Ctor<T3>, m4?: C4 & Ctor<T4>, m5?: C5 & Ctor<T5>): ExtModel<T1 & T2 & T3 & T4 & T5, C1 & C2 & C3 & C4 & C5>;

// @public (undocumented)
export function GtPlugin(metadata: GtPluginMetadataArgs): ClassDecorator;

// @public (undocumented)
export interface GtPluginMetadataArgs<T = any> {
    // (undocumented)
    options?: T;
    // (undocumented)
    plugin(schema: mongoose.Schema, options: T): void;
    // (undocumented)
    plugin(schema: mongoose.Schema): void;
}

// @public (undocumented)
export function GtQuery<Q1>(QH: Ctor<Q1>): <T, C>(Cls: ExtModel<T, C> & C) => Ctor<Document_2 & T> & C & ModelExtensions<Q1>;

// @public (undocumented)
export function GtQuery<Q1, Q2>(Q1: Ctor<Q1>, Q2: Ctor<Q2>): <T, C>(Cls: ExtModel<T, C> & C) => Ctor<Document_2 & T> & C & ModelExtensions<Q1 & Q2>;

// @public (undocumented)
export function GtQuery<Q1, Q2, Q3>(Q1: Ctor<Q1>, Q2: Ctor<Q2>, Q3: Ctor<Q3>): <T, C>(Cls: ExtModel<T, C> & C) => Ctor<Document_2 & T> & C & ModelExtensions<Q1 & Q2 & Q3>;

// @public (undocumented)
export function GtQuery<Q1, Q2, Q3, Q4>(Q1: Ctor<Q1>, Q2: Ctor<Q2>, Q3: Ctor<Q3>, Q4: Ctor<Q4>): <T, C>(Cls: ExtModel<T, C> & C) => Ctor<Document_2 & T> & C & ModelExtensions<Q1 & Q2 & Q3 & Q4>;

// @public (undocumented)
export function GtRemoveHook(stage: 'pre' | 'post'): MethodDecoratorOf<never, any>;

// @public (undocumented)
export function GtResource(): Ctor<SubDocument> & Resource;

// @public (undocumented)
export function GtResource<T1, C1>(m1: C1 & Ctor<T1>): Ctor<SubDocument & T1> & Resource & C1;

// @public (undocumented)
export function GtResource<T1, C1, T2, C2>(m1: C1 & Ctor<T1>, m2: C2 & Ctor<T2>): Ctor<SubDocument & T1 & T2> & Resource & C1 & C2;

// @public (undocumented)
export function GtResource<T1, C1, T2, C2, T3, C3>(m1: C1 & Ctor<T1>, m2: C2 & Ctor<T2>, m3: C3 & Ctor<T3>): Ctor<SubDocument & T1 & T2 & T3> & Resource & C1 & C2 & C3;

// @public (undocumented)
export function GtResource<T1, C1, T2, C2, T3, C3, T4, C4>(m1: C1 & Ctor<T1>, m2: C2 & Ctor<T2>, m3: C3 & Ctor<T3>, m4: C4 & Ctor<T4>): Ctor<SubDocument & T1 & T2 & T3 & T4> & Resource & C1 & C2 & C3 & C4;

// @public (undocumented)
export function GtResource<T1, C1, T2, C2, T3, C3, T4, C4, T5, C5>(m1: C1 & Ctor<T1>, m2: C2 & Ctor<T2>, m3: C3 & Ctor<T3>, m4: C4 & Ctor<T4>, m5: C5 & Ctor<T5>): Ctor<SubDocument & T1 & T2 & T3 & T4 & T5> & Resource & C1 & C2 & C3 & C4 & C5;

// @public (undocumented)
export function GtSaveHook(stage: 'pre' | 'post'): MethodDecoratorOf<never, any>;

// @public (undocumented)
export function GtSchemaType(metadata: GtSchemaTypeMetadataArgs): ClassDecorator;

// @public (undocumented)
export type GtSchemaTypeMetadataArgs = GtSchemaTypeSingleMetadataArgs | GtSchemaTypeContainerMetadataArgs;

// @public (undocumented)
export interface GtSingleIndexMetadataArgs {
    // (undocumented)
    options?: GtIndexOptions;
    // (undocumented)
    sort: GtIndexSortOrder;
}

// @public (undocumented)
export function GtSkipVersioning(): PropertyDecorator;

// @public (undocumented)
export function GtSubDocument(metadata?: GtSubDocumentMetadataArgs): ClassDecoratorOf<any, Resource>;

// @public (undocumented)
export interface GtSubDocumentMetadataArgs extends GtSchemaMetadataArgs {
    noId?: boolean;
}

// @public (undocumented)
export function GtTimestampCreated<T = Date>(): PropertyDecoratorOf<T>;

// @public (undocumented)
export function GtTimestampUpdated<T = Date>(): PropertyDecoratorOf<T>;

// @public
export function GtToJSON(config?: Omit<mongoose.ToObjectOptions, 'transform'>): MethodDecoratorOf<[any, any]>;

// @public
export function GtToObject(config?: Omit<mongoose.ToObjectOptions, 'transform'>): MethodDecoratorOf<[any, any]>;

// @public (undocumented)
export function GtUpdateOneHook(stage: 'pre' | 'post'): MethodDecoratorOf<never, any>;

// @public (undocumented)
export function GtValidateHook(stage: 'pre' | 'post'): MethodDecoratorOf<never, any>;

// @public (undocumented)
export function GtVersionKey<T = number>(): PropertyDecoratorOf<T>;

// @public (undocumented)
export function isDiscriminator(modelClass: Ctor<any>): 'root' | 'child' | undefined;

// @public (undocumented)
export function mapSchemaType(runtimeType: any, metadata: GtSchemaTypeMetadataArgs): void;

// @public (undocumented)
export type MethodDecoratorOf<TArgs extends [any] | [any, any] | [any, any, any] | [any, any, any, any] | [any, any, any, any, any] | [any, any, any, any, any, any] | [any, any, any, any, any, any, any] = never, TReturn = void> = <Z extends Partial<Record<K, (...args: TArgs) => TReturn>>, K extends string>(target: Z, key: K, descriptor: TypedPropertyDescriptor<(...args: TArgs) => TReturn>) => TypedPropertyDescriptor<(...args: TArgs) => TReturn> | void;

// @public (undocumented)
export interface ModelExtensions<TQueryHelpers = {}, TInstanceMethods = {}, TVirtuals = {}, TSchema = any> {
    $where<T>(this: Ctor<T>, argument: string | Function): DocumentQuery<Array<M.HydratedDocument<T, TVirtuals & TInstanceMethods, TQueryHelpers>>, M.HydratedDocument<T, TVirtuals & TInstanceMethods, TQueryHelpers>, TQueryHelpers, T, 'find'> & TQueryHelpers;
    // (undocumented)
    aggregate<T>(this: Ctor<T>, options?: M.AggregateOptions): M.Aggregate<Array<T>>;
    // (undocumented)
    aggregate<T = any>(this: Ctor<any>, pipeline: M.PipelineStage[], options?: M.AggregateOptions): M.Aggregate<Array<T>>;
    bulkSave<T>(this: Ctor<T>, documents: Array<M.Document>, options?: M.MongooseBulkSaveOptions): Promise<mongodb.BulkWriteResult>;
    bulkWrite<T>(this: Ctor<T>, writes: Array<M.AnyBulkWriteOperation<T extends M.Document ? any : (T extends {} ? T : any)>>, options: M.MongooseBulkWriteOptions & {
        ordered: false;
    }): Promise<mongodb.BulkWriteResult & {
        mongoose?: {
            validationErrors: Error[];
        };
    }>;
    // (undocumented)
    bulkWrite<T>(this: Ctor<T>, writes: Array<M.AnyBulkWriteOperation<T extends M.Document ? any : (T extends {} ? T : any)>>, options?: M.MongooseBulkWriteOptions): Promise<mongodb.BulkWriteResult>;
    collection: M.Collection;
    countDocuments<T>(this: Ctor<T>, filter?: M.FilterQuery<T>, options?: (mongodb.CountOptions & M.MongooseBaseQueryOptions<T>) | null): DocumentQuery<number, M.HydratedDocument<T, TVirtuals & TInstanceMethods, TQueryHelpers>, TQueryHelpers, T, 'countDocuments'> & TQueryHelpers;
    // (undocumented)
    create<T>(this: Ctor<T>, docs: Array<Partial<T>>, options: M.CreateOptions & {
        aggregateErrors: true;
    }): Promise<(M.HydratedDocument<T, TVirtuals & TInstanceMethods, TQueryHelpers> | M.Error)[]>;
    // (undocumented)
    create<T>(this: Ctor<T>, docs: Array<Partial<T>>, options: M.CreateOptions): Promise<M.HydratedDocument<T, TVirtuals & TInstanceMethods, TQueryHelpers>[]>;
    // (undocumented)
    create<T>(this: Ctor<T>, doc: Partial<T>): Promise<M.HydratedDocument<T, TVirtuals & TInstanceMethods, TQueryHelpers>>;
    // (undocumented)
    create<T>(this: Ctor<T>, doc1: Partial<T>, doc2: Partial<T>, ...docs: Array<Partial<T>>): Promise<M.HydratedDocument<T, TVirtuals & TInstanceMethods, TQueryHelpers>[]>;
    createCollection<T, D extends mongodb.Document>(this: Ctor<T>, options?: mongodb.CreateCollectionOptions & Pick<M.SchemaOptions, 'expires'>): Promise<mongodb.Collection<D>>;
    createSearchIndex<T>(this: Ctor<T>, description: M.SearchIndexDescription): Promise<string>;
    ctor<T extends M.Document>(this: Ctor<T>, doc?: Partial<T>): T;
    db: M.Connection;
    deleteMany<T>(this: Ctor<T>, filter?: M.FilterQuery<T>, options?: (mongodb.DeleteOptions & M.MongooseBaseQueryOptions<T>) | null): DocumentQuery<mongodb.DeleteResult, M.HydratedDocument<T, TVirtuals & TInstanceMethods, TQueryHelpers>, TQueryHelpers, T, 'deleteMany'> & TQueryHelpers;
    // (undocumented)
    deleteMany<T>(this: Ctor<T>, filter: M.FilterQuery<T>): DocumentQuery<mongodb.DeleteResult, M.HydratedDocument<T, TVirtuals & TInstanceMethods, TQueryHelpers>, TQueryHelpers, T, 'deleteMany'> & TQueryHelpers;
    deleteOne<T>(this: Ctor<T>, filter?: M.FilterQuery<T>, options?: (mongodb.DeleteOptions & M.MongooseBaseQueryOptions<T>) | null): DocumentQuery<mongodb.DeleteResult, M.HydratedDocument<T, TVirtuals & TInstanceMethods, TQueryHelpers>, TQueryHelpers, T, 'deleteOne'> & TQueryHelpers;
    // (undocumented)
    deleteOne<T>(this: Ctor<T>, filter: M.FilterQuery<T>): DocumentQuery<mongodb.DeleteResult, M.HydratedDocument<T, TVirtuals & TInstanceMethods, TQueryHelpers>, TQueryHelpers, T, 'deleteOne'> & TQueryHelpers;
    dropSearchIndex<T>(this: Ctor<T>, name: string): Promise<void>;
    find<T, ResultDoc = M.HydratedDocument<T, TVirtuals & TInstanceMethods, TQueryHelpers>>(this: Ctor<T>, filter: M.FilterQuery<T>, projection: M.ProjectionType<T> | null | undefined, options: M.QueryOptions<T> & {
        lean: true;
    }): DocumentQuery<M.GetLeanResultType<T, T[], 'find'>, ResultDoc, TQueryHelpers, T, 'find'> & TQueryHelpers;
    // (undocumented)
    find<T, ResultDoc = M.HydratedDocument<T, TVirtuals & TInstanceMethods, TQueryHelpers>>(this: Ctor<T>, filter: M.FilterQuery<T>, projection?: M.ProjectionType<T> | null | undefined, options?: M.QueryOptions<T> | null | undefined): DocumentQuery<Array<ResultDoc>, ResultDoc, TQueryHelpers, T, 'find'> & TQueryHelpers;
    // (undocumented)
    find<T, ResultDoc = M.HydratedDocument<T, TVirtuals & TInstanceMethods, TQueryHelpers>>(this: Ctor<T>, filter: M.FilterQuery<T>, projection?: M.ProjectionType<T> | null | undefined): DocumentQuery<Array<ResultDoc>, ResultDoc, TQueryHelpers, T, 'find'> & TQueryHelpers;
    // (undocumented)
    find<T, ResultDoc = M.HydratedDocument<T, TVirtuals & TInstanceMethods, TQueryHelpers>>(this: Ctor<T>, filter: M.FilterQuery<T>): DocumentQuery<Array<ResultDoc>, ResultDoc, TQueryHelpers, T, 'find'> & TQueryHelpers;
    // (undocumented)
    find<T, ResultDoc = M.HydratedDocument<T, TVirtuals & TInstanceMethods, TQueryHelpers>>(this: Ctor<T>): DocumentQuery<Array<ResultDoc>, ResultDoc, TQueryHelpers, T, 'find'> & TQueryHelpers;
    findById<T, ResultDoc = M.HydratedDocument<T, TVirtuals & TInstanceMethods, TQueryHelpers>>(this: Ctor<T>, id: any, projection: M.ProjectionType<T> | null | undefined, options: M.QueryOptions<T> & {
        lean: true;
    }): DocumentQuery<M.GetLeanResultType<T, T, 'findOne'> | null, ResultDoc, TQueryHelpers, T, 'findOne'> & TQueryHelpers;
    // (undocumented)
    findById<T, ResultDoc = M.HydratedDocument<T, TVirtuals & TInstanceMethods, TQueryHelpers>>(this: Ctor<T>, id: any, projection?: M.ProjectionType<T> | null, options?: M.QueryOptions<T> | null): DocumentQuery<ResultDoc | null, ResultDoc, TQueryHelpers, T, 'findOne'> & TQueryHelpers;
    // (undocumented)
    findById<T, ResultDoc = M.HydratedDocument<T, TVirtuals & TInstanceMethods, TQueryHelpers>>(this: Ctor<T>, id: any, projection?: M.ProjectionType<T> | null): DocumentQuery<ResultDoc | null, ResultDoc, TQueryHelpers, T, 'findOne'> & TQueryHelpers;
    // (undocumented)
    findOne<T, ResultDoc = M.HydratedDocument<T, TVirtuals & TInstanceMethods, TQueryHelpers>>(this: Ctor<T>, filter: M.FilterQuery<T>, projection: M.ProjectionType<T> | null | undefined, options: M.QueryOptions<T> & {
        lean: true;
    }): DocumentQuery<M.GetLeanResultType<T, T, 'findOne'> | null, ResultDoc, TQueryHelpers, T, 'findOne'> & TQueryHelpers;
    // (undocumented)
    findOne<T, ResultDoc = M.HydratedDocument<T, TVirtuals & TInstanceMethods, TQueryHelpers>>(this: Ctor<T>, filter?: M.FilterQuery<T>, projection?: M.ProjectionType<T> | null, options?: M.QueryOptions<T> | null): DocumentQuery<ResultDoc | null, ResultDoc, TQueryHelpers, T, 'findOne'> & TQueryHelpers;
    // (undocumented)
    findOne<T, ResultDoc = M.HydratedDocument<T, TVirtuals & TInstanceMethods, TQueryHelpers>>(this: Ctor<T>, filter?: M.FilterQuery<T>, projection?: M.ProjectionType<T> | null): DocumentQuery<ResultDoc | null, ResultDoc, TQueryHelpers, T, 'findOne'> & TQueryHelpers;
    // (undocumented)
    findOne<T, ResultDoc = M.HydratedDocument<T, TVirtuals & TInstanceMethods, TQueryHelpers>>(this: Ctor<T>, filter?: M.FilterQuery<T>): DocumentQuery<ResultDoc | null, ResultDoc, TQueryHelpers, T, 'findOne'> & TQueryHelpers;
    // (undocumented)
    init<T>(this: Ctor<T>): Promise<M.HydratedDocument<T, TVirtuals & TInstanceMethods, TQueryHelpers>>;
    insertMany<T>(this: Ctor<T>, docs: Array<T>): Promise<Array<M.HydratedDocument<T, TVirtuals & TInstanceMethods, TQueryHelpers>>>;
    // (undocumented)
    insertMany<T>(this: Ctor<T>, docs: Array<T>, options: M.InsertManyOptions & {
        lean: true;
    }): Promise<Array<M.Require_id<T>>>;
    // (undocumented)
    insertMany<T>(this: Ctor<T>, doc: Array<T>, options: M.InsertManyOptions & {
        ordered: false;
        rawResult: true;
    }): Promise<mongodb.InsertManyResult<M.Require_id<T>> & {
        mongoose: {
            validationErrors: (M.CastError | M.Error.ValidatorError)[];
            results: Array<M.Error | Object | M.HydratedDocument<T, TVirtuals & TInstanceMethods, TQueryHelpers>>;
        };
    }>;
    // (undocumented)
    insertMany<T>(this: Ctor<T>, docs: Array<T>, options: M.InsertManyOptions & {
        lean: true;
        rawResult: true;
    }): Promise<mongodb.InsertManyResult<M.Require_id<T>>>;
    // (undocumented)
    insertMany<T>(this: Ctor<T>, docs: Array<T>, options: M.InsertManyOptions & {
        rawResult: true;
    }): Promise<mongodb.InsertManyResult<M.Require_id<M.HydratedDocument<T, TVirtuals & TInstanceMethods, TQueryHelpers>>>>;
    // (undocumented)
    insertMany<T>(this: Ctor<T>, doc: Array<T>, options: M.InsertManyOptions): Promise<Array<M.HydratedDocument<T, TVirtuals & TInstanceMethods, TQueryHelpers>>>;
    // (undocumented)
    model<T>(this: Ctor<T>): M.Model<T, TQueryHelpers, TInstanceMethods, TVirtuals>;
}

// @public (undocumented)
export class ObjectId extends String {
}

// @public (undocumented)
export type PropertyDecoratorOf<T> = <Z extends Partial<Record<K, T>>, K extends string>(target: Z, key: K) => void;

// @public (undocumented)
export interface Resource<T = unknown> {
    // (undocumented)
    [GT_SUB_DOCUMENT]: boolean;
    // (undocumented)
    new (doc?: any): SubDocument & T;
    ctor<T extends SubDocument>(this: Ctor<T>, doc: Partial<T>): T;
    // (undocumented)
    prototype: SubDocument & T;
    // (undocumented)
    schema: M.Schema;
}

// @public (undocumented)
export type StaticMethodDecoratorOf<TArgs extends [any] | [any, any] | [any, any, any] | [any, any, any, any] | [any, any, any, any, any] | [any, any, any, any, any, any] | [any, any, any, any, any, any, any] = never, TReturn = void> = <Z extends Function & Partial<Record<K, (...args: TArgs) => TReturn>>, K extends string>(target: Z, key: K, descriptor: TypedPropertyDescriptor<(...args: TArgs) => TReturn>) => TypedPropertyDescriptor<(...args: TArgs) => TReturn> | void;

// @public
export type StripDoc<T extends Document_2, TExcept extends keyof Document_2 = never> = Subtract<T, Omit<Document_2, TExcept>>;

// @public
export type StripDoColumns<T extends Document_2, TExcept extends keyof Document_2 = never> = Pick<T, SetDifference<NonFunctionKeys<T>, Exclude<keyof Document_2, TExcept>>>;

// @public (undocumented)
export interface SubDocument {
}

// @public (undocumented)
export type Type<TInstance, TStatic> = Ctor<TInstance> & TStatic;

// @public
export type Validator = RegExp | ValidatorFn | ValidatorOpts | ValidatorOpts[];

// @public (undocumented)
export type ValidatorFn<T = any> = (value: T) => boolean | Promise<boolean>;

// @public (undocumented)
export interface ValidatorMessageContext {
    // (undocumented)
    path: string;
    // (undocumented)
    reason: string | Error;
    // (undocumented)
    value: any;
}

// @public (undocumented)
export interface ValidatorOpts<T = any> {
    // (undocumented)
    message?: string | ((props: ValidatorMessageContext) => string);
    // (undocumented)
    validator: ValidatorFn<T>;
}

// (No @packageDocumentation comment for this package)

```
