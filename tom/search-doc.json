[{"title":"Core Module","type":0,"sectionRef":"#","url":"docs/basics/core-module","content":"The core module, @pebula/tom provides no user functionality by itself. @pebula/tom contains the core logic, tools and constructs on which all other modules build meaningful functionalities. In the core module there are mini-frameworks which are the base of all operations. It is mainly the source for: Schema type framework, including Type System representationSchema decoration Management JIT JS code generation framework Other core utilities The core module is highly extensible, design to be so other modules can use it to built domain specific functionality. More specifically, serialization, validation, and mapping","keywords":""},{"title":"Modules","type":0,"sectionRef":"#","url":"docs/basics/modules","content":"TBD...","keywords":""},{"title":"Basic Usage","type":0,"sectionRef":"#","url":"docs/getting-started/basic-usage","content":"TBD...","keywords":""},{"title":"Installation","type":0,"sectionRef":"#","url":"docs/getting-started/installation","content":"To get started install the package: YarnNPM $ yarn add @pebula/tom Copy","keywords":""},{"title":"Schema","type":0,"sectionRef":"#","url":"docs/basics/schema","content":"","keywords":""},{"title":"Decorators","type":1,"pageTitle":"Schema","url":"docs/basics/schema#decorators","content":"To obtain metadata we need to allow the user to express it. One simple way is to have the user provide a schema object which is not natural, verbose and most importantly not type-safe. We want to allow the user to define it's own classes and while doing it express the metadata required based on the domain logic. We achieve this via decorators: class Order { @P id: number; @P date: Date; @P shipped: boolean; @P.enum(OrderStatus) status: OrderStatus; @P.asArray('string') coupons: string[]; } Copy In the example above, we used the decorator P to mark the properties we want to be part of the schema for the class Order. By doing so, typescript automatically provide us runtime information about the type. I.E. TOM knows that: There is a class OrderIt is made out of 5 properties (id, date, shipped, status, coupons)id is a number, date is a Date and so on... "},{"title":"Special Type Information","type":1,"pageTitle":"Schema","url":"docs/basics/schema#special-type-information","content":"Typescript decorators can provide a limited runtime reflection of the types. It can not reflect enumsIt can not reflect unresolved objects (circular reference classes)It can not reflect generics Array<string> will reflect as ArraySet<string> will reflect as SetMap<string, string> will reflect as MapEtc... To workaround these limitations several decorators are used. class PreTest { @P v: number; } class Test { @P.enum(MyEnum) v1: MyEnum; @P.asArray('string') v2: string[]; @P.asSet('string') v3: Set<string>; @P.asMap('string', 'date') v4: Map<Date, string>; // 2nd type param (data) is optional @P.asObjectMap('date') v5: Record<string, Date>; // 2nd type param (data) is optional @P.asTuple('string', 'number', 'boolean') v6: [string, number, boolean]; @P.literal('xyz') v7: 'xyz'; @P.union('string', 'date', @P.literal(99), P.asArray('number')) v8: string | Date | 99 | number[]; @P v9: PreTest; // This will work cause `PreTest` is already defined @P.as(() => PostTest) v10: PostTest; // This must be wrapped in a function, as reference to the type, because it is still undefined when the decorator is invoked. } class PostTest { @P v: number; } Copy info Decorators are only valid on a class, a class method or a class property. "},{"title":"Introduction","type":0,"sectionRef":"#","url":"docs/getting-started/introduction","content":"","keywords":""},{"title":"Supported Types","type":1,"pageTitle":"Introduction","url":"docs/getting-started/introduction#supported-types","content":"TOM supports a wide list of types, almost any type out there is supported! The obvious primitives: boolean, number, string, Date & BigIntAll native containers: Array, Set, Map & object map (dictionary, POJO)All native buffers: ArrayBuffer and all of the typed arrays (Int8Array, Uint8Array, etc...)EnumNested Types/ClassesType Literals (boolean, number, string)Union (unions of all of the above) If you have an exotic type that is not supported, extending the framework is relatively easy. Of course, you can always request to add it. "},{"title":"Mapping Introduction","type":0,"sectionRef":"#","url":"docs/mapping/mapping-introduction","content":"","keywords":""},{"title":"TBD","type":1,"pageTitle":"Mapping Introduction","url":"docs/mapping/mapping-introduction#tbd","content":"Mapping Definition Mapping definition VS Schema definitionsStrict definition, explain whyMapping definitions of un-equal types Why & How toGotchas: Types.String, Nominal, true as 3rd param Mapping between 2 classesreversing a mappingAuto Mapping to self (cloning)Reusing/Extending an existing mapping "},{"title":"Basic Usage","type":0,"sectionRef":"#","url":"docs/mapping/basic-usage","content":"import { defineClassMapping, getMapper } from '@pebula/tom/mapping'; class OrderDto implements Models.OrderDto { @P id: number; @P date: string; @P shipped: boolean; @P status: string; @P.asArray(() => OrderItemDto) items: OrderItemDto[]; @P eTag: string; } class OrderItemDto implements Models.OrderItemDto { @P sku: string; @P quantity: number; @P price: number; } class Order implements Models.Order { @P id: number; @P date: Date; @P shipped: boolean; @P.enum(OrderStatus) status: OrderStatus; @P.asArray(() => OrderItem) items: OrderItem[]; } class OrderItem implements Models.OrderItem { @P sku: string; @P quantity: number; @P price: number; } defineClassMapping(OrderItemDto, OrderItem, { 'strict' }) .forMember('sku', 'sku') .forMember('price', 'price') .forMember('quantity', 'quantity') .seal(); defineClassMapping(OrderDto, Order, { 'strict' }) .forMember('id', 'id') .forMember('date', 'date', Types.String) // Convert string to Date .forMember('shipped', 'shipped') .forMember('status', 'status', true) // Convert enum value .forMember('items', 'items') .forMember('eTag', c => c.ignore() ) // We must ignore or we can seal (enforced on design & runtime level) .seal(); const mapper = getMapper(OrderDto, Order); const orderDto = new OrderDto(); // Assume populating OrderDto and OrderItemDto items const order = mapper.transform(orderDto, {}); Copy","keywords":""},{"title":"Basic Usage","type":0,"sectionRef":"#","url":"docs/serialization/basic-usage","content":"import { P, jsonSerializer } from '@pebula/tom/serialization'; class Order { @P id: number; @P date: Date; @P shipped: boolean; @P.enum(OrderStatus) status: OrderStatus; @P.asArray(() => OrderItem) items: OrderItem[]; } class OrderItem { @P sku: string; @P quantity: number; @P price: number; } const orderSerializer = jsonSerializer .setDefault('jitCompiler', 'strict') .add(OrderItem) .create(Order); const order: Order = orderSerializer.deserialize({ id: Date.now(), date: new Date().toISOString(), shipped: true, status: 'paid', items: [ { sku: 'R107-7', quantity: 4, price: 32.22 }, { sku: 'C112-9', quantity: 1, price: 3.51 }, { sku: 'Q343-11', quantity: 12, price: 1.23 }, { sku: 'P232-33', quantity: 2, price: 1223 } ] }); const serializedOrder = orderSerializer.serialize(order); Copy","keywords":""},{"title":"Serialization Introduction","type":0,"sectionRef":"#","url":"docs/serialization/serialization-introduction","content":"","keywords":""},{"title":"TBD","type":1,"pageTitle":"Serialization Introduction","url":"docs/serialization/serialization-introduction#tbd","content":"Serialization Definition Serialization definition VS Schema definitionsStrict definition, explain whySerialization definitions of un-equal types Why & How toGotchas: Types.String, Nominal, true as 3rd param Auto definition (based on Schema)Enums - Labels vs ValuesReusing/Extending an existing serialization definitionThe Serializer The default jsonSerializerExtending/Forking a SerializerAdvanced: Type specific Serializer Extending/Cloning a type serializerOverwriting a type serializer "},{"title":"Serializer","type":0,"sectionRef":"#","url":"docs/serialization/serializer","content":"TBD...","keywords":""},{"title":"Basic Usage","type":0,"sectionRef":"#","url":"docs/validation/basic-usage","content":"import { P, defaultValidator } from '@pebula/tom/serialization'; export class BasicModelTom { @P number: number; @P.negative negNumber: number; @P.max(500) maxNumber: number; @P.asArray('string') strings: string[]; @P longString: string; @P boolean: boolean; @P.as(() => BasicModelNestedTom) deeplyNested: BasicModelNested; } export class BasicModelNestedTom { @P foo: string; @P num: number; @P bool: boolean; } const validator = defaultValidator.factory(BasicModelTom); const model = { number: 1, negNumber: -1, maxNumber: 200, strings: ['a', 'b', 'c'], longString: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation...', boolean: true, deeplyNested: { foo: 'bar', num: 1, bool: false } }; const result = validator(model); if (result !== true) { // result contains errors } Copy","keywords":""},{"title":"Validation Introduction","type":0,"sectionRef":"#","url":"docs/validation/validation-introduction","content":"","keywords":""},{"title":"TBD","type":1,"pageTitle":"Validation Introduction","url":"docs/validation/validation-introduction#tbd","content":"Validation using decorators Schema decorators VS validation decoratorsWhy no Definitions (like mapping & serialization)Excluding validation Auto definition (based on Schema)Reusing/Extending an existing serialization definitionThe Validator The default validatorExtending/Forking a ValidatorAdvanced: Type specific constraints group Customizing Error validation messagesExtending/Cloning a Type specific constraints groupOverwriting a Type specific constraints groupLogical constraintAdding new constraints Decorator Extensions (+ augmentation)RegisterJIT & Runtime CodeError messages "},{"title":"Validator","type":0,"sectionRef":"#","url":"docs/validation/validator","content":"TBD...","keywords":""}]