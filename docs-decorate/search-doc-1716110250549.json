{"searchDocs":[{"title":"Decorator API Class","type":0,"sectionRef":"#","url":"/node/docs-decorate/docs/decorate-fluent/decorator-api-class","content":"","keywords":"","version":"Next"},{"title":"Building the API​","type":1,"pageTitle":"Decorator API Class","url":"/node/docs-decorate/docs/decorate-fluent/decorator-api-class#building-the-api","content":" import { FluentMethodPlugin, FluentPropertyPlugin, DecorPropertyApi, PropertySchema } from '@pebula/decorate/fluent'; export class MyPropertyDecoratorSchemaConfig extends PropertySchema { defaultValue?: any; optional?: boolean } export class MyPropertyDecoratorFluentApiClass extends DecorPropertyApi&lt;MyPropertyDecoratorSchemaConfig&gt; { // IGNORE THE CLASS BODY, THESE ARE THE PLUGINS AND WE WILL VISIT THEM NEXT SECTION @FluentPropertyPlugin() get optional(): this { this.$$context.schema.optional = true; return this; } @FluentMethodPlugin() default(value: any): this { this.$$context.schema.defaultValue = value; return this; } // Override the base class schema factory, teach it how to instantiate a new property schema configuration object. static schemaFactory(args: PropertyDecoratorArgs): TomPropertySchemaConfig { return new TomPropertySchemaConfig(args.key as string); } }   We define the schema configuration class, which extend PropertySchema (more on this later...) Then we define the API class which extends DecorPropertyApi of our schema configuration class.  The base classes we extend are mandatory and we must extend the one relevant to the class we extend.  Decorator\tSchema Config\tFluent API ClassClass\tClassSchema\tDecorClassApi Property\tPropertySchema\tDecorPropertyApi Method\tMethodSchema\tDecorMethodApi Parameter\tParameterSchema\tDecorParameterApi  tip Don't waste time on these types, the library provides helper to make this easy. We will cover them soon  If you're looking at this code and thinking, this is not really extensible you're right! This is a simple example to ease you in.  On the next page we'll review how to compose an API class from small plugin chunks (mixins) which make the API class empty from any code.  ","version":"Next","tagName":"h2"},{"title":"Custom Class Decorator API​","type":1,"pageTitle":"Decorator API Class","url":"/node/docs-decorate/docs/decorate-fluent/decorator-api-class#custom-class-decorator-api","content":" If we also implement a custom class decorator API we need to reflect it's schema configuration so our plugins will know how the class schema looks like.  import { DecorPropertyApi, PropertySchema } from '@pebula/decorate/fluent'; import { MyClassDecoratorSchemaConfig } from './some-where'; // Type info on the class schema config export class MyPropertyDecoratorFluentApiClass extends DecorPropertyApi&lt;MyPropertyDecoratorSchemaConfig, MyClassDecoratorSchemaConfig&gt; { }   ","version":"Next","tagName":"h3"},{"title":"Plugins​","type":1,"pageTitle":"Decorator API Class","url":"/node/docs-decorate/docs/decorate-fluent/decorator-api-class#plugins","content":" Plugins are instructions we add to the API, by so extending the API. A plugin provides logic that will run once it is called, allowing the plugin to add the metadata required.  class X { @P.optional.default(50) value: number }   In the example above, P is the decorator, optional and default are the plugins.  There are 2 types of fluent API plugins:  FluentPropertyPlugin - A property plugin (get accessor) which does not require input (optional above)FluentMethodPlugin - A method plugin which requires input (default above, getting 50 as input)  And a general API plugin:  MethodPlugin - A method plugin  Do not confuse the fluent property/method plugin with the fluent API suite property and method APIs. The fluent API suite sets the decorator type. A property decorator can only decorate properties, etc... The fluent property/method plugin instruct the type of member on the API.  info The different between FluentMethodPlugin amd MethodPlugin is that FluentMethodPlugin must return the same type (design time) &amp; value (runtime) of the context it was called from (this). MethodPlugin can return any type and matching value it desires, possibly breaking the fluent API chain.  Fluent is highly extensible, allowing plugins to be added from multiple locations in both libraries and ad-hoc application. You can add features on demand, allowing clear separation when developing new plugins.  ","version":"Next","tagName":"h2"},{"title":"Design Time and Runtime​","type":1,"pageTitle":"Decorator API Class","url":"/node/docs-decorate/docs/decorate-fluent/decorator-api-class#design-time-and-runtime","content":" The library is type safe and must keep design time data accurate to provide a solid user experience.  In fluent, the design time is as important as the runtime  Because fluent is plugin based and can be extended from any location it also provide the tools to extend the type system along side the runtime.  The design time is generated as part of building the runtime process and requires an additional 3-line effort of pairing it via type augmentation. ","version":"Next","tagName":"h2"},{"title":"Decorator API Class Mixins","type":0,"sectionRef":"#","url":"/node/docs-decorate/docs/decorate-fluent/composing-decorator-api-class","content":"","keywords":"","version":"Next"},{"title":"Mixins​","type":1,"pageTitle":"Decorator API Class Mixins","url":"/node/docs-decorate/docs/decorate-fluent/composing-decorator-api-class#mixins","content":" A Mixin is small encapsulated logical container which implement a specific behavior which can be mixed into another class.  With mixins we want to be able to write plugins in small, encapsulated and reuseable classes or better yet download them as a node_module package  We then import them and mix them onto our main Fluent Decorator API class adding their behavior to our API.  Mixin 101 JavaScript does not allow multiple inheritance, a class may only extend from a single class. To workaround this limitation we use Mixins. Mixins are classes which are not extends but merged into a host class extending their functionality (methods, accessors) onto the host. Simply put, copying all of the property descriptors (static and prototype) onto the host class. There is one constraint with Mixins, they are treated as abstract classes, never initialized nor their constructor invoked Read more about mixins in the TypeScript Documentation for Mixins  The library provides all of the tools to handle mixins, including handling of the combined type of all mixins, through the namespaces ApiMixin &amp; SchemaMixin.  ","version":"Next","tagName":"h2"},{"title":"Decorator API Composition​","type":1,"pageTitle":"Decorator API Class Mixins","url":"/node/docs-decorate/docs/decorate-fluent/composing-decorator-api-class#decorator-api-composition","content":" Going back to our property class decorator API MyPropertyDecoratorFluentApiClass, let's re-write it to use mixin plugins instead of coding them in the body  Decorator API./optional.ts./default.ts import { PropertyDecoratorArgs } from '@pebula/decorate'; import { SchemaMixin, ApiMixin } from '@pebula/decorate/fluent'; import { OptionalSchemaConfig, OptionalPluginApi } from './options'; import { DefaultSchemaConfig, DefaultPluginApi } from './default'; export class MyPropertyDecoratorSchemaConfig extends SchemaMixin.Property().With(OptionalSchemaConfig, DefaultSchemaConfig) { } export class MyPropertyDecoratorFluentApiClass extends ApiMixin.Property&lt;MyPropertyDecoratorSchemaConfig&gt;().With(OptionalPluginApi, DefaultPluginApi) { static schemaFactory(args: PropertyDecoratorArgs): MyPropertyDecoratorSchemaConfig { return new MyPropertyDecoratorSchemaConfig(args.key as string); } }   Couple of points:  Plugins do not extend the same class the main Fluent Decorator API class does (e.g. DecorPropertyApi). Instead, they extend a designated mixin base class, ApiMixin.MixinBase, following the template type used as their schema configuration object. Extending from MixinBase is mandatory, the framework will not accept mixins that does not originate from MixinBase. The main Fluent Decorator API class and Schema Configuration class now have a different extend expression  note We've forced one plugin for each optional and default. In real life plugins usually group several members which share the same logical idea.  caution On this page we address the composition of a Fluent Decorator API class through a base class mixin. That is, we create a new base class and mix in all of our mixins into the new base class, we then declare a class which extend the new mixed in base class. This is the classic approach to mixins. There is another mixin scenario where a Fluent Decorator API class already exists and we want to extend it after the fact. This is bit more advanced as it requires using typescript augmentation and a slightly different mixin behavior. For example, a node module you've installed which uses the Fluent library and you would like to extend it.... We'll discuss this topic in a later phase ","version":"Next","tagName":"h2"},{"title":"Decorator API Suite","type":0,"sectionRef":"#","url":"/node/docs-decorate/docs/decorate-fluent/decorator-api-suite","content":"","keywords":"","version":"Next"},{"title":"Suite Decorators​","type":1,"pageTitle":"Decorator API Suite","url":"/node/docs-decorate/docs/decorate-fluent/decorator-api-suite#suite-decorators","content":" As you might have noticed, in the previous example we exported 2 decorators, not 1. Actually, there are 4 types of decorators, based on the different decorators that exist in the language.  There is a clear separation between the different decorator types in TypeScript. Each decorator type has a unique API.  The 4 Decorators Are: Class decoratorProperty DecoratorMethod DecoratorParameter Decorator  Each decorator is a unique API, built from a decorator API class which represent the API structure. Going back to our example:  C will expose the fluent api defined in MyClassDecoratorFluentApiClassP will expose the fluent api defined in MyPropertyDecoratorFluentApiClass  We've only used 2 in this case but you can use all 4 if required.  ","version":"Next","tagName":"h2"},{"title":"Decorator API Class​","type":1,"pageTitle":"Decorator API Suite","url":"/node/docs-decorate/docs/decorate-fluent/decorator-api-suite#decorator-api-class","content":" MyClassDecoratorFluentApiClass &amp; MyPropertyDecoratorFluentApiClass are Fluent Decorator API classes.  The structure of MyPropertyDecoratorFluentApiClass class will get reflected in P as if P is an instance of MyPropertyDecoratorFluentApiClass as well as a property decorator method.  The Decorator API class holds the structure of the API as well as the implementation of the plugins and the schema configuration class.  On to the next page to learn more about the Decorator API class.  ","version":"Next","tagName":"h2"},{"title":"API Suite Store​","type":1,"pageTitle":"Decorator API Suite","url":"/node/docs-decorate/docs/decorate-fluent/decorator-api-suite#api-suite-store","content":" The store is simply where all Schema Configuration objects are stored, mapped to their respective target. ","version":"Next","tagName":"h2"},{"title":"Real Life Example","type":0,"sectionRef":"#","url":"/node/docs-decorate/docs/decorate-fluent/example","content":"Real Life Example class X { @P.optional.default(50) value: number } The fluent API decorator expression above is a valid expression from the library @pebula/tom. It is defined within @pebula/tom using @pebula/decorate/fluent. The expression tells @pebula/tom that the property value is optional and it has the default value 50. This enables validation, serialization, etc... to be done by @pebula/tom. import { FluentMethodPlugin, FluentPropertyPlugin, ApiMixin } from '@pebula/decorate/fluent'; export class PropertyMetadataSchema { defaultValue?: any; optional?: boolean } export abstract class PropertyMetadataApi extends ApiMixin.MixinBase&lt;PropertyMetadataSchema&gt; { @FluentPropertyPlugin() get optional(): this { this.$$context.schema.optional = true; return this; } @FluentMethodPlugin() default(value: any): this { this.$$context.schema.defaultValue = value; return this; } } We ignore the mixin expression for now... All we need to know is that this.$$context.schema has the optional property typed because of the mixin expression. Now, when @pebula/tom wants to build a schema for the class X it will query for Moving on... @pebula/tom/validation is a validation library based on @pebula/tom, if imported it will extend the fluent API so the following expression is valid: class X { @P.optional.default(50).min(5).max(5000).not.equal(999) value: number } The expression tells @pebula/tom/validation that on top of what known already (optional, default) the value must also be between 5 and 5000 but not 999. Yes, the entire API is type-safe with full intellisense support!Yes, we extended both design time type information and runtime support for the extension methods (min, max, equal, not) info If @pebula/tom/validation is not imported, the expression would cause a TypeScript compilation (design time) error. The API is defined using @pebula/decorate/fluent, mostly in @pebula/tom but it is so powerful that","keywords":"","version":"Next"},{"title":"Installation","type":0,"sectionRef":"#","url":"/node/docs-decorate/docs/getting-started/installation","content":"Installation To get started install the package: YarnNPM $ yarn add @pebula/decorate ","keywords":"","version":"Next"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/node/docs-decorate/docs/decorate-fluent/introduction","content":"","keywords":"","version":"Next"},{"title":"TL;DR​","type":1,"pageTitle":"Introduction","url":"/node/docs-decorate/docs/decorate-fluent/introduction#tldr","content":" Take a decorator function and make it a Fluent API object that can enrich the metadata for the decorated property.  Another way to visualize it:  class X { @P({ optional: true, default: 50, }) value: number }   Convert the above API to:  class X { @P.optional.default(50) value: number }   While allowing plugins, adding functionality on the fly, type safety and more...  note You can achieve the same results with each of the approaches above, including type enforcement, plugin system, etc... It is just a matter of preference.  ","version":"Next","tagName":"h2"},{"title":"Overview​","type":1,"pageTitle":"Introduction","url":"/node/docs-decorate/docs/decorate-fluent/introduction#overview","content":" With Fluent, we define plugins which compose a Fluent Decorator API. The end-user uses this API to define the metadata. The API will store the metadata in a Schema Configuration object, bound to the decorated target. We can then query for the Schema Configuration for a target and use it to implement our business logic.  Let's break it down:    (1) With Fluent, we define plugins which compose a Fluent Decorator API. The end-user uses this API to define the metadata.    class X { @P.optional.default(50) value: number }   optional and default are plugins which we implement and they create the Fluent Decorator API. They are not part of the library, we call them plugins because they extends the bare naked decorator (P above).  For each plugin, we provide a function that will handle the input and change the state.    (2) The API will store the metadata in a Schema Configuration object, bound to the decorated target.    We mentioned that the plugin implementations we provide will change the state. We call this state Schema Configuration and it is a fully typed interface we provide when extending the API with plugins.  An abstract illustration of the optional &amp; default plugin:  class SchemaConfig { defaultValue?: any; isOptional?: boolean; } class Plugin { get optional(): this { this.$$context.schema.isOptional = true; return this; } default(value: any): this { this.$$context.schema.defaultValue = value; return this; } }   Where this.$$context.schema extends SchemaConfig    (3) We can then query for the Schema Configuration for a target and use it to implement our business logic.    Basically, we ask the library if it has a SchemaConfig for a class. If it does, we can implement our logic.  class X { @P.optional.default(50) value: number }   Above, when we query for a Schema Configuration for X, we will get back the following SchemaConfig instance:  { &quot;defaultValue&quot;: 50, &quot;isOptional&quot;: true };   Now, we can implement our logic.  For example, if we build a validation/sanitation library we will be able to set the value 50 to the property value if it is not set.  Now we're ready to start the walk-through!  ","version":"Next","tagName":"h2"},{"title":"Fluent Decorator API​","type":1,"pageTitle":"Introduction","url":"/node/docs-decorate/docs/decorate-fluent/introduction#fluent-decorator-api","content":" A fluent decorator API is a decorator method which also contains additional methods and properties.  In the following end-user example:  class X { @P.optional.default(50) value: number }   P is the decorator, it also returns and object with the optional and default members. Each of these members is also the P decorator as well as returning the same object as P.  We can describe the API using the following interface:  interface DecoratorFluentApi { (target: object, key: string | symbol, descriptor?: PropertyDescriptor): PropertyDescriptor | void; optional: this; default(value: any): this; }   A fluent decorator API means that at each point, the value return must be a valid decorator but also the context for an additional API operation. ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/node/docs-decorate/docs/decorate/introduction","content":"","keywords":"","version":"Next"},{"title":"Structure​","type":1,"pageTitle":"Introduction","url":"/node/docs-decorate/docs/decorate/introduction#structure","content":" There are 2 key components:  Decorator domainTarget Classifier  In Decorate we use decorator domains to create strictly typed decorator functions. All decorators created by the domain are bound to it, grouped together storing the metadata for their decorated targets in the same place, the domain.  A domain uses a target classifier class to manage metadata related operation for each decorated target. When creating a new domain you can provide your own target classifier class which extends the core classifier, override some of it's behavior and make work for your requirements.  When a new decorated target is introduces, a new target classifier instance is created, which will store all metadata created by decorators of the domain for that target.  info A decorated target is the class a decorator decorates (including member decoration). class MyDecoratedTarget { @MyDecorator value: number } In the example above, MyDecoratedTarget is a decorated target.  ","version":"Next","tagName":"h2"},{"title":"Mixins​","type":1,"pageTitle":"Introduction","url":"/node/docs-decorate/docs/decorate/introduction#mixins","content":" MixinFW + Mixin in decorate Maybe in chapter on TargetClassifier and how it extends metadata  ","version":"Next","tagName":"h2"},{"title":"Decorator Domain​","type":1,"pageTitle":"Introduction","url":"/node/docs-decorate/docs/decorate/introduction#decorator-domain","content":" A decorator domains is like a store which is able to generate decorators and store all the metadata created when they get invoked.  import { DecoratedDomain } from '@pebula/decorate'; export const domain = new DecoratedDomain();   Now we have a new domain which we can use to create decorators from.  const MyDecor = domain.createDecorator({ name: 'MyDecor', allowedScopes: ['property'], classifierData: { } // any data you want to pass forward }); const MyDecorFlat = domain.createImmediateDecorator({ name: 'MyDecorFlat', allowedScopes: ['property'], classifierData: { } // any data you want to pass forward });   Targets decorated by decorators created in our new domain will be stored in the domain.  class MyApplicationClass { @MyDecor() value: number; @MyDecorFlat value2: number; }   When a decorator is activated, the domain is notified and it will start generating a metadata record. The domain has no logic, so we add logic that &quot;tells&quot; the domain what to do when a decorated is invoked.  The logic is places inside the TargetClassifier class. When a target class is first decorated the domain assign's a classifier to it (TargetClassifier) which will store all metadata from all decorators on the domain which are invoked on this target.  The domain will operate using methods on the classifier. It will use the classifier to:  Create a new metadata recordsExtend the metadata from existing metadata on an already decorated base classQuery if the target has metadata for a given decorator  The TargetClassifier class contains all of the functionality above but it can be replaced by a custom class, which extends TargetClassifier.  export const domain = new DecoratedDomain(MyCustomTargetClassifier);   ","version":"Next","tagName":"h2"},{"title":"Target Classifier​","type":1,"pageTitle":"Introduction","url":"/node/docs-decorate/docs/decorate/introduction#target-classifier","content":" By default when we create a new domain:  import { DecoratedDomain } from '@pebula/decorate'; export const domain = new DecoratedDomain();   The domain is created with the TargetClassifier class as the class to manage targets. We can modify this behavior:  class MyTargetClassifier extends TargetClassifier { protected createRecord(decor: Decorator | DecoratorInitializer&lt;TRecordMeta&gt;, record: ClassifierRecord&lt;TRecordMeta&gt;, options: DecoratorOptions): TRecord { // override behavior } protected extendDecoratorMetadata(targetClassifier: TargetClassifier) { // override behavior } } export const domain = new DecoratedDomain(MyTargetClassifier);  ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/node/docs-decorate/docs/getting-started/introduction","content":"","keywords":"","version":"Next"},{"title":"Background​","type":1,"pageTitle":"Introduction","url":"/node/docs-decorate/docs/getting-started/introduction#background","content":" Decorators are mostly used for 2 scenarios:  Mutating the decorated targetCollecting metadata on the decorated target  We'll focus on the 2nd scenario, metadata.  When building metadata driven applications, we collect metadata about classes / objects which we can then use to automate workflows, perform operations and in general drive an application.  For example, an express application is given a mapping of predefined routes to their handlers. These mappings are metadata and the express engine is using it to drive incoming request to their designated handlers.  Traditionally this was done manually:  app.get('/orders/:id', (req, res, next) =&gt; { /* do something */ });   With modern TypeScript it can be done like this:  @Controller('orders') class OrdersController { @Get(':id') async getOrder(id: number) { /* do something */ } }   This is where Decorate comes in. It provides the infrastructure to easily:  Store and retrieve metadata per decorated target (e.g. OrdersController above)Implement custom logic when a decorator is used (invoked)Build type-safe decorator API the helps the user drive the metadata definition process  ","version":"Next","tagName":"h2"},{"title":"Library Structure​","type":1,"pageTitle":"Introduction","url":"/node/docs-decorate/docs/getting-started/introduction#library-structure","content":" The library contains 2 packages:  @pebula/decorate The core library, provide the tools for decorator management, life-cycle flow and storage. @pebula/decorate/fluent An extension library, provide the tools for building extensible, fluent API decorators  ","version":"Next","tagName":"h2"},{"title":"Decorate​","type":1,"pageTitle":"Introduction","url":"/node/docs-decorate/docs/getting-started/introduction#decorate","content":" The core library is where metadata is created, organized and stored. It is where decorators are created and where we build build the logic of how we create the metadata.  If your goal is to build a metadata driven application where decorators perform their classic rule as functions use the core library. It will abstract the metadata management, decorator factory and other mundane processes and let you focus on the logic of your application.  @Controller('orders') class OrdersController { @Get(':id') async getOrder(id: number) { /* do something */ } }   Click to read more about the core library...  ","version":"Next","tagName":"h3"},{"title":"Decorate Fluent​","type":1,"pageTitle":"Introduction","url":"/node/docs-decorate/docs/getting-started/introduction#decorate-fluent","content":" The fluent extensions is built on top of the core library. It provides a plugin infrastructure to build fluent API decorators where the process of defining metadata is self explaining, easy and automatically routed by the type system.  @Controller('orders') .authenticated .authorize('admin', 'warehouse') class OrdersController { @Get(':id') .authorize('admin') .openApi('Get and order by the ID') async getOrder(id: number) { /* do something */ } }   In fluent a plugin is used to extend the decorator API. The extension is done in 2 areas, the design time type system and for the runtime.  The plugin can be a get accessor (authenticated above) or a method with input params (authorize above).  Fluent is highly extensible, allowing plugins to be added from multiple locations in both libraries and ad-hoc application. You can add features on demand, allowing clear separation when developing new plugins.  info The fluent example above is presented to emphasize the different between the 2 libraries so it is similar to the example above it. It might not be the best fit to describe an MVC controller based API and it is completely up to your preferences. In general, the fluent API approach is a best fit for class schema definitions. class X { @P.optional.default(50).min(5).max(5000).not.equal(999) value: number }   Click to read more about the decorator fluent library... ","version":"Next","tagName":"h3"}],"options":{"id":"default"}}